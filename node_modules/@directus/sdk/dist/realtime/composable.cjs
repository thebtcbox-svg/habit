const e=require(`./commands/auth.cjs`),t=require(`./commands/pong.cjs`),n=require(`./utils/generate-uid.cjs`),r=require(`./utils/message-callback.cjs`),i={authMode:`handshake`,heartbeat:!0,debug:!1,connect:{timeout:1e4},reconnect:{delay:1e3,retries:10}};function a(a={}){return o=>{a={...i,...a};let s=n.generateUid(),c={code:`closed`},l={attempts:0,active:!1},u=!1,d=new Set,f=e=>`getToken`in e,p=(e,...t)=>a.debug&&o.globals.logger[e](`[Directus SDK]`,...t),m=async(e,t)=>{let n=new o.globals.URL(e);if(a.authMode===`strict`&&f(t)){let e=await t.getToken();e&&n.searchParams.set(`access_token`,e)}return n.toString()},h=async e=>{if(`url`in a)return await m(a.url,e);if([`ws:`,`wss:`].includes(o.url.protocol))return await m(o.url,e);let t=new o.globals.URL(o.url.toString());return t.protocol=o.url.protocol===`https:`?`wss:`:`ws:`,t.pathname=`/websocket`,await m(t,e)},g=e=>{let t=new Promise((t,n)=>{if(!a.reconnect||u)return n();if(p(`info`,`reconnect #${l.attempts} `+(l.attempts>=a.reconnect.retries?`maximum retries reached`:`trying again in ${Math.max(100,a.reconnect.delay)}ms`)),l.active)return l.active;if(l.attempts>=a.reconnect.retries)return l.attempts=-1,n();setTimeout(()=>e.connect().then(t=>(d.forEach(t=>{e.sendMessage(t)}),t)).then(t).catch(n),Math.max(100,a.reconnect.delay))});l.attempts+=1,l.active=t.catch(()=>{}).finally(()=>{l.active=!1})},_={open:new Set([]),error:new Set([]),close:new Set([]),message:new Set([])};function v(e){return`type`in e&&`status`in e&&`error`in e&&`code`in e.error&&`message`in e.error&&e.type===`auth`&&e.status===`error`}async function y(t,n){if(c.code===`open`){if(t.error.code===`TOKEN_EXPIRED`&&(p(`warn`,`Authentication token expired!`),f(n))){let t=await n.getToken();if(!t)throw Error(`No token for re-authenticating the websocket`);c.connection.send(e.auth({access_token:t}))}if(t.error.code===`AUTH_TIMEOUT`)return c.firstMessage&&a.authMode===`public`?(p(`warn`,`Authentication failed! Currently the "authMode" is "public" try using "handshake" instead`),a.reconnect=!1):p(`warn`,`Authentication timed out!`),c.connection.close();if(t.error.code===`AUTH_FAILED`){if(c.firstMessage&&a.authMode===`public`)return p(`warn`,`Authentication failed! Currently the "authMode" is "public" try using "handshake" instead`),a.reconnect=!1,c.connection.close();p(`warn`,`Authentication failed!`)}}}let b=async e=>{for(;c.code===`open`;){let n=await r.messageCallback(c.connection).catch(()=>{});if(n){if(v(n)){await y(n,e),c.firstMessage=!1;continue}if(a.heartbeat&&n.type===`ping`){c.connection.send(t.pong()),c.firstMessage=!1;continue}_.message.forEach(e=>{c.code===`open`&&e.call(c.connection,n)}),c.firstMessage=!1}}};return{async connect(){if(u=!1,c.code===`connecting`)return await c.connection;if(c.code!==`closed`)throw Error(`Cannot connect when state is "${c.code}"`);let t=this,i=await h(t);p(`info`,`Connecting to ${i}...`);let d=new Promise((u,d)=>{let m=!1,h=new o.globals.WebSocket(i),v;a.connect&&(v=setTimeout(()=>{d(`Connection attempt timed out.`)},a.connect.timeout??1e4)),h.addEventListener(`open`,async n=>{if(p(`info`,`Connection open.`),c={code:`open`,connection:h,firstMessage:!0},l.attempts=0,l.active=!1,clearTimeout(v),b(t),a.authMode===`handshake`&&f(t)){let n=await t.getToken();if(!n)return d(`No token for authenticating the websocket. Make sure to provide one or call the login() function beforehand.`);h.send(e.auth({access_token:n}));let i=await r.messageCallback(h);if(i&&`type`in i&&`status`in i&&i.type===`auth`&&i.status===`ok`)p(`info`,`Authentication successful!`);else return d(`Authentication failed while opening websocket connection`)}_.open.forEach(e=>e.call(h,n)),m=!0,u(h)}),h.addEventListener(`error`,e=>{p(`warn`,`Connection errored.`),_.error.forEach(t=>t.call(h,e)),h.close(),c={code:`error`},m||d(e)}),h.addEventListener(`close`,e=>{p(`info`,`Connection closed.`),_.close.forEach(t=>t.call(h,e)),s=n.generateUid(),c={code:`closed`},g(this),m||d(e)})});return c={code:`connecting`,connection:d},d},disconnect(){u=!0,c.code===`open`&&c.connection.close()},onWebSocket(e,t){if(e===`message`){let n=function(e){if(typeof e.data!=`string`)return t.call(this,e);try{return t.call(this,JSON.parse(e.data))}catch{return t.call(this,e)}};return _[e].add(n),()=>_[e].delete(n)}return _[e].add(t),()=>_[e].delete(t)},sendMessage(e){if(c.code!==`open`)throw Error(`Cannot send messages without an open connection. Make sure you are calling "await client.connect()".`);if(typeof e==`string`)return c.connection.send(e);`uid`in e||(e.uid=s.next().value),c.connection.send(JSON.stringify(e))},async subscribe(e,t={}){`uid`in t||(t.uid=s.next().value),d.add({...t,collection:e,type:`subscribe`}),c.code!==`open`&&(p(`info`,`No connection available for subscribing!`),await this.connect()),this.sendMessage({...t,collection:e,type:`subscribe`});let n=!0;async function*i(){for(;n&&c.code===`open`;){let e=await r.messageCallback(c.connection).catch(()=>{});if(e){if(`type`in e&&`status`in e&&e.type===`subscribe`&&e.status===`error`)throw e;`type`in e&&`uid`in e&&e.type===`subscription`&&e.uid===t.uid&&(yield e)}}a.reconnect&&l.active&&(await l.active,c.code===`open`&&(c.connection.send(JSON.stringify({...t,collection:e,type:`subscribe`})),yield*i()))}return{subscription:i(),unsubscribe:()=>{d.delete({...t,collection:e,type:`subscribe`}),this.sendMessage({uid:t.uid,type:`unsubscribe`}),n=!1}}}}}}exports.realtime=a;
//# sourceMappingURL=composable.cjs.map