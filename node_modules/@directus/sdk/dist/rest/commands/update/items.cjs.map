{"version":3,"file":"items.cjs","names":["payload: Record<string, any>"],"sources":["../../../../src/rest/commands/update/items.ts"],"sourcesContent":["import type { ApplyQueryFields, CollectionType, NestedPartial, Query, UnpackList } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\nimport { throwIfCoreCollection, throwIfEmpty } from '../../utils/index.js';\n\nexport type UpdateItemOutput<\n\tSchema,\n\tCollection extends keyof Schema,\n\tTQuery extends Query<Schema, Schema[Collection]>,\n> = ApplyQueryFields<Schema, CollectionType<Schema, Collection>, TQuery['fields']>;\n\n/**\n * Update multiple items at the same time.\n *\n * @param collection The collection of the items\n * @param keysOrQuery The primary keys or a query\n * @param item The item data to update\n * @param query Optional return data query\n *\n * @returns Returns the item objects for the updated items.\n * @throws Will throw if keysOrQuery is empty\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n */\nexport const updateItems =\n\t<Schema, Collection extends keyof Schema, const TQuery extends Query<Schema, Schema[Collection]>>(\n\t\tcollection: Collection,\n\t\tkeysOrQuery: string[] | number[] | Query<Schema, Schema[Collection]>,\n\t\titem: NestedPartial<UnpackList<Schema[Collection]>>,\n\t\tquery?: TQuery,\n\t): RestCommand<UpdateItemOutput<Schema, Collection, TQuery>[], Schema> =>\n\t() => {\n\t\tlet payload: Record<string, any> = {};\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use updateItems for core collections');\n\n\t\tif (Array.isArray(keysOrQuery)) {\n\t\t\tthrowIfEmpty(keysOrQuery, 'keysOrQuery cannot be empty');\n\t\t\tpayload = { keys: keysOrQuery };\n\t\t} else {\n\t\t\tthrowIfEmpty(Object.keys(keysOrQuery), 'keysOrQuery cannot be empty');\n\t\t\tpayload = { query: keysOrQuery };\n\t\t}\n\n\t\tpayload['data'] = item;\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(payload),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update multiple items as batch.\n *\n * @param collection The collection of the items\n * @param items The items to update\n * @param query Optional return data query\n *\n * @returns Returns the item objects for the updated items.\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n */\nexport const updateItemsBatch =\n\t<Schema, Collection extends keyof Schema, const TQuery extends Query<Schema, Schema[Collection]>>(\n\t\tcollection: Collection,\n\t\titems: NestedPartial<UnpackList<Schema[Collection]>>[],\n\t\tquery?: TQuery,\n\t): RestCommand<UpdateItemOutput<Schema, Collection, TQuery>[], Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use updateItems for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(items),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update an existing item.\n *\n * @param collection The collection of the item\n * @param key The primary key of the item\n * @param item The item data to update\n * @param query Optional return data query\n *\n * @returns Returns the item object of the item that was updated.\n * @throws Will throw if key is empty\n * @throws Will throw if collection is empty\n * @throws Will throw if collection is a core collection\n */\nexport const updateItem =\n\t<\n\t\tSchema,\n\t\tCollection extends keyof Schema,\n\t\tconst TQuery extends Query<Schema, Schema[Collection]>,\n\t\tItem = UnpackList<Schema[Collection]>,\n\t>(\n\t\tcollection: Collection,\n\t\tkey: string | number,\n\t\titem: NestedPartial<Item>,\n\t\tquery?: TQuery,\n\t): RestCommand<UpdateItemOutput<Schema, Collection, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\t\tthrowIfEmpty(String(collection), 'Collection cannot be empty');\n\t\tthrowIfCoreCollection(collection, 'Cannot use updateItem for core collections');\n\n\t\treturn {\n\t\t\tpath: `/items/${collection as string}/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n"],"mappings":"qGAuBa,GAEX,EACA,EACA,EACA,QAEK,CACL,IAAIA,EAA+B,EAAE,CAcrC,OAbA,EAAA,aAAa,OAAO,EAAW,CAAE,6BAA6B,CAC9D,EAAA,sBAAsB,EAAY,8CAA8C,CAE5E,MAAM,QAAQ,EAAY,EAC7B,EAAA,aAAa,EAAa,8BAA8B,CACxD,EAAU,CAAE,KAAM,EAAa,GAE/B,EAAA,aAAa,OAAO,KAAK,EAAY,CAAE,8BAA8B,CACrE,EAAU,CAAE,MAAO,EAAa,EAGjC,EAAQ,KAAU,EAEX,CACN,KAAM,UAAU,IAChB,OAAQ,GAAS,EAAE,CACnB,KAAM,KAAK,UAAU,EAAQ,CAC7B,OAAQ,QACR,EAcU,GAEX,EACA,EACA,SAGA,EAAA,aAAa,OAAO,EAAW,CAAE,6BAA6B,CAC9D,EAAA,sBAAsB,EAAY,8CAA8C,CAEzE,CACN,KAAM,UAAU,IAChB,OAAQ,GAAS,EAAE,CACnB,KAAM,KAAK,UAAU,EAAM,CAC3B,OAAQ,QACR,EAgBU,GAOX,EACA,EACA,EACA,SAGA,EAAA,aAAa,OAAO,EAAI,CAAE,sBAAsB,CAChD,EAAA,aAAa,OAAO,EAAW,CAAE,6BAA6B,CAC9D,EAAA,sBAAsB,EAAY,6CAA6C,CAExE,CACN,KAAM,UAAU,EAAqB,GAAG,IACxC,OAAQ,GAAS,EAAE,CACnB,KAAM,KAAK,UAAU,EAAK,CAC1B,OAAQ,QACR"}