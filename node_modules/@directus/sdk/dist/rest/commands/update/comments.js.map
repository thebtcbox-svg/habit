{"version":3,"file":"comments.js","names":["payload: Record<string, any>"],"sources":["../../../../src/rest/commands/update/comments.ts"],"sourcesContent":["import type { DirectusComment } from '../../../schema/comment.js';\nimport type { ApplyQueryFields, NestedPartial, Query } from '../../../types/index.js';\nimport type { RestCommand } from '../../types.js';\nimport { throwIfEmpty } from '../../utils/index.js';\n\nexport type UpdateCommentOutput<\n\tSchema,\n\tTQuery extends Query<Schema, Item>,\n\tItem extends object = DirectusComment<Schema>,\n> = ApplyQueryFields<Schema, Item, TQuery['fields']>;\n\n/**\n * Update multiple existing comments.\n * @param keysOrQuery The primary keys or a query\n * @param item\n * @param query\n * @returns Returns the comment objects for the updated comments.\n * @throws Will throw if keys is empty\n */\nexport const updateComments =\n\t<Schema, const TQuery extends Query<Schema, DirectusComment<Schema>>>(\n\t\tkeysOrQuery: DirectusComment<Schema>['id'][] | Query<Schema, DirectusComment<Schema>>,\n\t\titem: NestedPartial<DirectusComment<Schema>>,\n\t\tquery?: TQuery,\n\t): RestCommand<UpdateCommentOutput<Schema, TQuery>[], Schema> =>\n\t() => {\n\t\tlet payload: Record<string, any> = {};\n\n\t\tif (Array.isArray(keysOrQuery)) {\n\t\t\tthrowIfEmpty(keysOrQuery, 'keysOrQuery cannot be empty');\n\t\t\tpayload = { keys: keysOrQuery };\n\t\t} else {\n\t\t\tthrowIfEmpty(Object.keys(keysOrQuery), 'keysOrQuery cannot be empty');\n\t\t\tpayload = { query: keysOrQuery };\n\t\t}\n\n\t\tpayload['data'] = item;\n\n\t\treturn {\n\t\t\tpath: `/comments`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(payload),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n\n/**\n * Update multiple comments as batch.\n * @param items\n * @param query\n * @returns Returns the comment objects for the updated comments.\n */\nexport const updateCommentsBatch =\n\t<Schema, const TQuery extends Query<Schema, DirectusComment<Schema>>>(\n\t\titems: NestedPartial<DirectusComment<Schema>>[],\n\t\tquery?: TQuery,\n\t): RestCommand<UpdateCommentOutput<Schema, TQuery>[], Schema> =>\n\t() => ({\n\t\tpath: `/comments`,\n\t\tparams: query ?? {},\n\t\tbody: JSON.stringify(items),\n\t\tmethod: 'PATCH',\n\t});\n\n/**\n * Update an existing comment.\n * @param key\n * @param item\n * @param query\n * @returns Returns the comment object for the updated comment.\n * @throws Will throw if key is empty\n */\nexport const updateComment =\n\t<Schema, const TQuery extends Query<Schema, DirectusComment<Schema>>>(\n\t\tkey: DirectusComment<Schema>['id'],\n\t\titem: NestedPartial<DirectusComment<Schema>>,\n\t\tquery?: TQuery,\n\t): RestCommand<UpdateCommentOutput<Schema, TQuery>, Schema> =>\n\t() => {\n\t\tthrowIfEmpty(String(key), 'Key cannot be empty');\n\n\t\treturn {\n\t\t\tpath: `/comments/${key}`,\n\t\t\tparams: query ?? {},\n\t\t\tbody: JSON.stringify(item),\n\t\t\tmethod: 'PATCH',\n\t\t};\n\t};\n"],"mappings":"6DAmBA,MAAa,GAEX,EACA,EACA,QAEK,CACL,IAAIA,EAA+B,EAAE,CAYrC,OAVI,MAAM,QAAQ,EAAY,EAC7B,EAAa,EAAa,8BAA8B,CACxD,EAAU,CAAE,KAAM,EAAa,GAE/B,EAAa,OAAO,KAAK,EAAY,CAAE,8BAA8B,CACrE,EAAU,CAAE,MAAO,EAAa,EAGjC,EAAQ,KAAU,EAEX,CACN,KAAM,YACN,OAAQ,GAAS,EAAE,CACnB,KAAM,KAAK,UAAU,EAAQ,CAC7B,OAAQ,QACR,EASU,GAEX,EACA,SAEM,CACN,KAAM,YACN,OAAQ,GAAS,EAAE,CACnB,KAAM,KAAK,UAAU,EAAM,CAC3B,OAAQ,QACR,EAUW,GAEX,EACA,EACA,SAGA,EAAa,OAAO,EAAI,CAAE,sBAAsB,CAEzC,CACN,KAAM,aAAa,IACnB,OAAQ,GAAS,EAAE,CACnB,KAAM,KAAK,UAAU,EAAK,CAC1B,OAAQ,QACR"}