{"version":3,"file":"query-to-params.js","names":["fields","params: Record<string, string>","stringValue: string | undefined"],"sources":["../../../src/rest/utils/query-to-params.ts"],"sourcesContent":["import type { AggregationTypes, GroupByFields, Query } from '../../types/index.js';\n\ntype ExtendedQuery<Schema, Item> = Query<Schema, Item> & {\n\taggregate?: Partial<Record<keyof AggregationTypes, string>>;\n\tgroupBy?: (string | GroupByFields<Schema, Item>)[];\n\tversion?: string | undefined;\n\tversionRaw?: boolean | undefined;\n} & Record<string, unknown>;\n\nexport const formatFields = (fields: (string | Record<string, any>)[]) => {\n\ttype FieldItem = (typeof fields)[number];\n\n\tconst walkFields = (value: FieldItem, chain: string[] = []): string | string[] => {\n\t\tif (typeof value === 'object') {\n\t\t\tconst result = [];\n\n\t\t\tfor (const key in value) {\n\t\t\t\tconst nestedField = value[key as keyof typeof value] ?? [];\n\n\t\t\t\tif (Array.isArray(nestedField)) {\n\t\t\t\t\t// regular nested fields\n\t\t\t\t\tfor (const item of nestedField) {\n\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, key]));\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof nestedField === 'object') {\n\t\t\t\t\t// many to any nested\n\t\t\t\t\tfor (const scope of Object.keys(nestedField)) {\n\t\t\t\t\t\tconst fields = (nestedField as Record<string, FieldItem[]>)[scope]!;\n\n\t\t\t\t\t\tfor (const item of fields) {\n\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, `${key}:${scope}`]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result.flatMap((items) => items);\n\t\t}\n\n\t\treturn [...chain, String(value)].join('.');\n\t};\n\n\treturn fields.flatMap((value) => walkFields(value));\n};\n\nconst knownQueryKeys = [\n\t'fields',\n\t'filter',\n\t'search',\n\t'sort',\n\t'limit',\n\t'offset',\n\t'page',\n\t'deep',\n\t'backlink',\n\t'alias',\n\t'aggregate',\n\t'groupBy',\n\t'version',\n\t'versionRaw',\n];\n\n/**\n * Local utility functions\n */\nconst isBoolean = (value: unknown): value is boolean => typeof value === 'boolean';\nconst isString = (value: unknown): value is string => typeof value === 'string' && Boolean(value);\nconst isNumber = (value: unknown): value is number => typeof value === 'number';\nconst isArray = (value: unknown): value is unknown[] => Array.isArray(value) && value.length > 0;\n\nconst isObject = (value: unknown): value is Record<string, unknown> =>\n\ttypeof value === 'object' && value !== null && !isArray(value) && Object.keys(value).length > 0;\n\n/**\n * Transform nested query object to an url compatible format\n *\n * @param query The nested query object\n *\n * @returns Flat query parameters\n */\nexport const queryToParams = <Schema = any, Item = Record<string, unknown>>(\n\tquery: ExtendedQuery<Schema, Item>,\n): Record<string, string> => {\n\tconst params: Record<string, string> = {};\n\n\tif (query.fields) {\n\t\tif (isArray(query.fields)) params['fields'] = formatFields(query.fields).join(',');\n\t\t// backwards JS compatibility for `fields: \"id,name\"`\n\t\tif (isString(query.fields)) params['fields'] = query.fields;\n\t}\n\n\tif (isObject(query.filter)) params['filter'] = JSON.stringify(query.filter);\n\n\tif (isString(query.search)) params['search'] = query.search;\n\n\tif (query.sort) {\n\t\tif (isArray(query.sort)) params['sort'] = query.sort.join(',');\n\t\tif (isString(query.sort)) params['sort'] = query.sort;\n\t}\n\n\tif ('limit' in query) {\n\t\tif (isNumber(query.limit) && query.limit >= -1) params['limit'] = String(query.limit);\n\t\t// backwards JS compatibility for string limits\n\t\tif (isString(query.limit)) params['limit'] = query.limit;\n\t}\n\n\tif ('offset' in query) {\n\t\tif (isNumber(query.offset) && query.offset >= 0) params['offset'] = String(query.offset);\n\t\t// backwards JS compatibility for string offsets\n\t\tif (isString(query.offset)) params['offset'] = query.offset;\n\t}\n\n\tif ('page' in query) {\n\t\tif (isNumber(query.page) && query.page >= 1) params['page'] = String(query.page);\n\t\t// backwards JS compatibility for string pages\n\t\tif (isString(query.page)) params['page'] = query.page;\n\t}\n\n\tif (isObject(query.deep)) params['deep'] = JSON.stringify(query.deep);\n\n\tif (isObject(query.alias)) params['alias'] = JSON.stringify(query.alias);\n\n\tif (isObject(query.aggregate)) params['aggregate'] = JSON.stringify(query.aggregate);\n\n\tif (query.groupBy) {\n\t\tif (isArray(query.groupBy)) params['groupBy'] = query.groupBy.join(',');\n\t\t// backwards JS compatibility for `groupBy: \"id,name\"`\n\t\tif (isString(query.groupBy)) params['groupBy'] = query.groupBy;\n\t}\n\n\tif (isString(query.version)) params['version'] = query.version;\n\n\tif (query.versionRaw) {\n\t\tif (isBoolean(query.versionRaw)) params['versionRaw'] = String(query.versionRaw);\n\t\t// backwards JS compatibility for `versionRaw: \"true\"`\n\t\tif (isString(query.versionRaw)) params['versionRaw'] = query.versionRaw;\n\t}\n\n\t// parse custom parameters\n\tfor (const [key, value] of Object.entries(query)) {\n\t\tif (knownQueryKeys.includes(key)) continue;\n\t\tlet stringValue: string | undefined;\n\n\t\tif (typeof value === 'string') {\n\t\t\tstringValue = value;\n\t\t} else {\n\t\t\t// `JSON.stringify` can return `undefined` for types it cannot serialize\n\t\t\t// Example: JSON.stringify(() => {}) -> undefined\n\t\t\tstringValue = JSON.stringify(value) as string | undefined;\n\t\t}\n\n\t\tif (stringValue) {\n\t\t\tparams[key] = stringValue;\n\t\t}\n\t}\n\n\treturn params;\n};\n"],"mappings":"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"}